<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
  <title>Snake — Drag Controls + Textures + High Score</title>
  <style>
    :root {
      --bg: #0b1020;
      --panelA: #111a33;
      --panelB: #0f1830;
      --text: #e6edf6;
      --muted: #9fb0c7;
      --accent: #22c55e;
      --warning: #f59e0b;
      --border: #213055;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 10% 5%, #0f1730 0%, #0b1020 60%, #070a15 100%);
      display: grid;
      place-items: center;
      padding: 16px;
      -webkit-tap-highlight-color: transparent;
    }
    .app {
      width: 100%;
      max-width: 1100px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 900px) {
      .app { grid-template-columns: 1fr 340px; }
    }
    .card {
      background: linear-gradient(180deg, var(--panelA), var(--panelB));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .stack { display: grid; gap: 8px; }
    .title { font-weight: 800; letter-spacing: .3px; font-size: 18px; }
    .small { color: var(--muted); font-size: 12px; }
    .pill { background: #162448; border: 1px solid var(--border); border-radius: 12px; padding: 6px 10px; font-size: 14px; color: var(--text); }
    .btn {
      border: 0; border-radius: 12px; padding: 10px 14px; font-weight: 700; cursor: pointer;
      color: #0a0f1f; background: #dbeafe;
      box-shadow: 0 2px 0 rgba(255,255,255,0.08) inset, 0 6px 16px rgba(0,0,0,0.25);
    }
    .btn:hover { filter: brightness(1.03); }
    .btn:active { transform: translateY(1px); }
    .btn-start { background: var(--accent); }
    .btn-pause { background: var(--warning); }
    .btn-danger { background: #fca5a5; }
    .canvas-wrap { aspect-ratio: 1 / 1; width: 100%; max-width: 620px; margin: 0 auto; border-radius: 16px; overflow: hidden; border: 1px solid var(--border); background:#000; touch-action: none; }
    canvas { display:block; width:100%; height:100%; }
    .controls { display: grid; gap: 14px; }
    .ctrl { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
    .ctrl label { font-size: 14px; color: var(--muted); }
    .ctrl input[type="color"] {
      width: 46px; height: 32px; padding:0; background: transparent; border: 1px solid var(--border); border-radius: 8px;
    }
    .ctrl input[type="range"] { width: 100%; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f172a; border:1px solid #1e293b; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="row" style="margin-bottom:10px">
        <div class="stack">
          <div class="title">Snake — Drag to Steer</div>
          <div class="small">
            Drag or swipe on the board to change direction (no buttons). Keyboard also works: <span class="kbd">WASD</span>/<span class="kbd">↑↓←→</span> · Space=pause · R=restart.
          </div>
        </div>
        <div class="row" style="gap:8px">
          <button id="startBtn" class="btn btn-start">Start</button>
          <button id="pauseBtn" class="btn btn-pause">Pause</button>
          <button id="restartBtn" class="btn">Restart</button>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px">
        <span class="pill"><strong>Score:</strong> <span id="score">0</span></span>
        <span class="pill"><strong>Best:</strong> <span id="best">0</span></span>
        <button id="resetBest" class="btn btn-danger" title="Clear saved high score">Reset High Score</button>
      </div>

      <div class="canvas-wrap">
        <canvas id="game" width="600" height="600" aria-label="Snake game canvas"></canvas>
      </div>
      <div class="small" style="margin-top:8px;text-align:center">
        Tip: Keep your finger on the board and nudge in the direction you want to turn—dragging across corners works too.
      </div>
    </div>

    <div class="card">
      <div class="title">Appearance & Settings</div>
      <div class="controls">
        <div class="ctrl">
          <label for="snakeColor">Snake color</label>
          <input id="snakeColor" type="color" value="#10b981" />
        </div>
        <div class="ctrl">
          <label for="foodColor">Snack color</label>
          <input id="foodColor" type="color" value="#ef4444" />
        </div>
        <div class="ctrl">
          <label for="bgColor">Background</label>
          <input id="bgColor" type="color" value="#0b1020" />
        </div>
        <div class="ctrl">
          <label for="gridToggle">Grid</label>
          <input id="gridToggle" type="checkbox" checked />
        </div>
        <div class="ctrl" style="flex-direction:column; align-items:stretch">
          <label for="speed">Speed: <span id="speedVal">10</span> ticks/sec</label>
          <input id="speed" type="range" min="5" max="20" step="1" value="10" />
        </div>
        <div class="row">
          <button id="randomize" class="btn" style="width:100%">Randomize Colors</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const COLS = 25;
    const ROWS = 25;
    const TILE = 24; // logical pixels per tile
    const WIDTH = COLS * TILE;
    const HEIGHT = ROWS * TILE;
    const HS_KEY = 'snake_highscore_v3';

    // ===== DOM =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const resetBestBtn = document.getElementById('resetBest');
    const snakeColorInput = document.getElementById('snakeColor');
    const foodColorInput = document.getElementById('foodColor');
    const bgColorInput = document.getElementById('bgColor');
    const gridToggle = document.getElementById('gridToggle');
    const speedInput = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

    // Scale canvas for crispness
    function resizeCanvas() {
      const w = WIDTH * dpr;
      const h = HEIGHT * dpr;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw(); // redraw after resize
    }
    resizeCanvas();

    // ===== State =====
    let snake = [
      { x: 8, y: 12 },
      { x: 7, y: 12 },
      { x: 6, y: 12 },
    ];
    let dir = { x: 1, y: 0 };
    let lastDir = { x: 1, y: 0 }; // last applied move direction (for 180° guard)
    let food = randFood(new Set(snake.map(s => key(s.x, s.y))));
    let isRunning = false;
    let isGameOver = false;
    let score = 0;
    let high = Number(localStorage.getItem(HS_KEY) || 0);
    bestEl.textContent = high;

    let tickHandle = null;
    let bgColor = bgColorInput.value;
    let snakeColor = snakeColorInput.value;
    let foodColor = foodColorInput.value;
    let gridOn = gridToggle.checked;
    let speed = Number(speedInput.value);
    speedVal.textContent = speed;

    // Gesture state
    let dragging = false;
    let gestureAnchor = null; // {x,y} logical coordinates where the last turn was committed
    let gesturePos = null;    // current pointer pos for indicator

    // Textures (patterns)
    let snakePattern = makeSnakePattern(snakeColor);
    let snackPattern = makeSnackPattern(foodColor);

    // ===== Utils =====
    function key(x, y) { return x + ',' + y; }
    function randFood(snakeSet) {
      while (true) {
        const x = Math.floor(Math.random() * COLS);
        const y = Math.floor(Math.random() * ROWS);
        if (!snakeSet.has(key(x, y))) return { x, y };
      }
    }
    function shade(hex, amt) {
      // amt in range [-100..100]; positive -> lighten, negative -> darken
      let c = hex.replace('#','');
      if (c.length === 3) c = c.split('').map(ch => ch+ch).join('');
      const num = parseInt(c, 16);
      let r = (num >> 16) & 0xff, g = (num >> 8) & 0xff, b = num & 0xff;
      r = Math.min(255, Math.max(0, r + Math.round(2.55 * amt)));
      g = Math.min(255, Math.max(0, g + Math.round(2.55 * amt)));
      b = Math.min(255, Math.max(0, b + Math.round(2.55 * amt)));
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    function randomHex() {
      const n = Math.floor(Math.random() * 0xffffff);
      return '#' + n.toString(16).padStart(6, '0');
    }
    function haptic(ms=8) { if ('vibrate' in navigator) navigator.vibrate(ms); }

    // ===== Textures / Patterns =====
    function makeSnakePattern(color) {
      const off = document.createElement('canvas');
      off.width = 16; off.height = 16;
      const c = off.getContext('2d');
      // Transparent base
      c.clearRect(0,0,16,16);
      // Diagonal stripes
      c.strokeStyle = shade(color, -35);
      c.lineWidth = 3;
      c.globalAlpha = 0.35;
      c.beginPath(); c.moveTo(-4, 16); c.lineTo(16, -4); c.stroke();
      c.beginPath(); c.moveTo(0, 20); c.lineTo(20, 0); c.stroke();
      c.beginPath(); c.moveTo(-8, 12); c.lineTo(12, -8); c.stroke();
      c.globalAlpha = 1;
      return ctx.createPattern(off, 'repeat');
    }
    function makeSnackPattern(color) {
      const off = document.createElement('canvas');
      off.width = 12; off.height = 12;
      const c = off.getContext('2d');
      c.clearRect(0,0,12,12);
      // Polka dots
      c.fillStyle = shade(color, 40);
      c.globalAlpha = 0.35;
      for (let y=2; y<12; y+=6) {
        for (let x=2; x<12; x+=6) {
          c.beginPath(); c.arc(x, y, 1.2, 0, Math.PI*2); c.fill();
        }
      }
      c.globalAlpha = 1;
      return ctx.createPattern(off, 'repeat');
    }
    function refreshPatterns() {
      snakePattern = makeSnakePattern(snakeColor);
      snackPattern = makeSnackPattern(foodColor);
      draw();
    }

    // ===== Game control =====
    function start() { if (!isGameOver && !isRunning) { isRunning = true; schedule(); } }
    function pause() { isRunning = false; if (tickHandle) clearInterval(tickHandle); tickHandle = null; draw(); }
    function restart() {
      snake = [ { x: 8, y: 12 }, { x: 7, y: 12 }, { x: 6, y: 12 } ];
      dir = { x: 1, y: 0 }; lastDir = { x: 1, y: 0 };
      food = randFood(new Set(snake.map(s => key(s.x, s.y))));
      isRunning = true; isGameOver = false; score = 0; scoreEl.textContent = score; schedule();
    }
    function schedule() { if (tickHandle) clearInterval(tickHandle); const ms = Math.max(40, 1000 / speed); tickHandle = setInterval(step, ms); }

    function step() {
      const head = snake[0];
      const newHead = { x: head.x + dir.x, y: head.y + dir.y };
      lastDir = { ...dir };

      if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) { endGame(); return; }
      for (let i = 0; i < snake.length; i++) { if (snake[i].x === newHead.x && snake[i].y === newHead.y) { endGame(); return; } }

      const ate = newHead.x === food.x && newHead.y === food.y;
      snake.unshift(newHead);
      if (!ate) snake.pop();
      if (ate) {
        score += 1; scoreEl.textContent = score;
        if (score > high) { high = score; bestEl.textContent = high; localStorage.setItem(HS_KEY, String(high)); }
        const snakeSet = new Set(snake.map(s => key(s.x, s.y))); food = randFood(snakeSet);
      }
      draw();
    }
    function endGame() {
      isGameOver = true; isRunning = false;
      if (tickHandle) clearInterval(tickHandle); tickHandle = null;
      draw();
    }

    // ===== Input: Keyboard =====
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if ([ 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'spacebar' ].includes(k)) e.preventDefault();
      if ((k === 'w' || k === 'arrowup')) trySetDir(0, -1);
      else if ((k === 's' || k === 'arrowdown')) trySetDir(0, 1);
      else if ((k === 'a' || k === 'arrowleft')) trySetDir(-1, 0);
      else if ((k === 'd' || k === 'arrowright')) trySetDir(1, 0);
      else if (k === ' ') { if (!isGameOver) (isRunning ? pause() : start()); }
      else if (k === 'r') { restart(); }
    }, { passive: false });

    // ===== Input: Drag anywhere on the canvas =====
    // Logic: as you drag, when movement from the last committed 'gestureAnchor' exceeds threshold,
    // pick the dominant axis and set direction (guarding against 180° turns).
    canvas.addEventListener('pointerdown', (e) => {
      dragging = true;
      gestureAnchor = getCanvasPos(e);
      gesturePos = gestureAnchor;
      canvas.setPointerCapture(e.pointerId);
      e.preventDefault();
      if (!isRunning && !isGameOver) start();
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      gesturePos = getCanvasPos(e);
      const dx = gesturePos.x - gestureAnchor.x;
      const dy = gesturePos.y - gestureAnchor.y;
      const ax = Math.abs(dx), ay = Math.abs(dy);
      const THRESH = 12; // pixels to trigger a turn
      if (ax < THRESH && ay < THRESH) { draw(); return; }
      // Determine intended direction based on dominant axis
      let ndx = 0, ndy = 0;
      if (ax > ay) ndx = dx > 0 ? 1 : -1; else ndy = dy > 0 ? 1 : -1;
      const changed = trySetDir(ndx, ndy);
      if (changed) {
        haptic(8);
        // reset anchor so additional movement requires a fresh threshold
        gestureAnchor = { ...gesturePos };
      }
      draw();
      e.preventDefault();
    }, { passive: false });

    function endDrag(e) {
      if (!dragging) return;
      dragging = false; gestureAnchor = null; gesturePos = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
      draw();
    }
    canvas.addEventListener('pointerup', endDrag, { passive: true });
    canvas.addEventListener('pointercancel', endDrag, { passive: true });
    canvas.addEventListener('pointerleave', endDrag, { passive: true });

    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      // convert to logical units (account for DPR transform)
      const x = (e.clientX - rect.left) / (rect.width) * WIDTH;
      const y = (e.clientY - rect.top) / (rect.height) * HEIGHT;
      return { x, y };
    }

    function trySetDir(x, y) {
      if (x === 0 && y === 0) return false;
      if (lastDir.x + x === 0 && lastDir.y + y === 0) return false; // block 180°
      // If we're not moving yet (game hasn't ticked), also block immediate reverse of current dir.
      if (dir.x + x === 0 && dir.y + y === 0) return false;
      dir = { x, y };
      return true;
    }

    // ===== Drawing =====
    function draw() {
      // background
      ctx.save();
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // grid
      if (gridOn) {
        ctx.globalAlpha = 0.18;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        for (let x = 0; x <= WIDTH; x += TILE) {
          ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, HEIGHT); ctx.stroke();
        }
        for (let y = 0; y <= HEIGHT; y += TILE) {
          ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(WIDTH, y + 0.5); ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      // snack with texture + glow
      drawFood(food.x, food.y, foodColor);

      // snake (head last to draw eyes on top)
      for (let i = snake.length - 1; i >= 0; i--) {
        const seg = snake[i]; const isHead = i === 0;
        drawBlock(seg.x, seg.y, snakeColor, isHead);
      }

      // drag indicator
      if (dragging && gestureAnchor && gesturePos) {
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(gestureAnchor.x, gestureAnchor.y);
        ctx.lineTo(gesturePos.x, gesturePos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        // end cap
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(gesturePos.x, gesturePos.y, 3.5, 0, Math.PI*2); ctx.fill();
      }

      if (isGameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.font = 'bold 28px Inter, system-ui, Segoe UI, Roboto';
        ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 12);
        ctx.font = '16px Inter, system-ui, Segoe UI, Roboto';
        ctx.fillText('Press R to restart', WIDTH / 2, HEIGHT / 2 + 16);
      }
      ctx.restore();
    }

    function drawBlock(gx, gy, color, head=false) {
      const x = gx * TILE, y = gy * TILE;
      const pad = 2, w = TILE - pad*2, h = TILE - pad*2, r = 5;
      // Base gradient (light on top, darker at bottom)
      const grad = ctx.createLinearGradient(0, y + pad, 0, y + pad + h);
      grad.addColorStop(0, shade(color, 30));
      grad.addColorStop(1, shade(color, -15));
      ctx.fillStyle = grad;
      roundRectPath(x + pad, y + pad, w, h, r);
      ctx.fill();

      // Texture overlay
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = snakePattern;
      roundRectPath(x + pad, y + pad, w, h, r);
      ctx.fill();
      ctx.restore();

      // Edge stroke
      ctx.strokeStyle = shade(color, -40);
      ctx.lineWidth = 1;
      roundRectPath(x + pad + 0.5, y + pad + 0.5, w - 1, h - 1, r - 1);
      ctx.stroke();

      if (head) {
        // Eyes
        ctx.fillStyle = '#000';
        const eye = Math.max(2, Math.floor(TILE * 0.12));
        const off = Math.max(3, Math.floor(TILE * 0.22));
        ctx.beginPath(); ctx.arc(x + TILE/2 - off, y + TILE/2 - off, eye, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + TILE/2 + off, y + TILE/2 - off, eye, 0, Math.PI*2); ctx.fill();
        // Subtle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.beginPath(); ctx.arc(x + TILE/2 - off - 1, y + TILE/2 - off - 1, Math.max(1, eye-1), 0, Math.PI*2); ctx.fill();
      }
    }

    function drawFood(gx, gy, color) {
      const cx = gx * TILE + TILE/2, cy = gy * TILE + TILE/2;
      const r = (TILE * 0.6) / 2;
      // Glow
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = 12;
      // Base radial gradient
      const rg = ctx.createRadialGradient(cx - r*0.35, cy - r*0.35, r*0.3, cx, cy, r);
      rg.addColorStop(0, shade(color, 30));
      rg.addColorStop(1, shade(color, -10));
      ctx.fillStyle = rg;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Texture overlay (dots)
      ctx.save();
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = snackPattern;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.clip();
      // Fill a rectangle that covers the circle with the pattern
      ctx.fillRect(cx - r, cy - r, r*2, r*2);
      ctx.restore();

      // Specular highlight
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath(); ctx.ellipse(cx - r*0.25, cy - r*0.35, r*0.35, r*0.2, -0.5, 0, Math.PI*2); ctx.fill();
      // Edge
      ctx.strokeStyle = shade(color, -35);
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
    }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, w/2, h/2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    // ===== Wire up UI =====
    startBtn.addEventListener('click', start);
    pauseBtn.addEventListener('click', pause);
    restartBtn.addEventListener('click', restart);
    resetBestBtn.addEventListener('click', () => {
      localStorage.removeItem(HS_KEY);
      high = 0;
      bestEl.textContent = high;
    });

    snakeColorInput.addEventListener('input', (e) => { snakeColor = e.target.value; refreshPatterns(); });
    foodColorInput.addEventListener('input', (e) => { foodColor = e.target.value; refreshPatterns(); });
    bgColorInput.addEventListener('input', (e) => { bgColor = e.target.value; draw(); });
    gridToggle.addEventListener('change', (e) => { gridOn = e.target.checked; draw(); });
    speedInput.addEventListener('input', (e) => { speed = Number(e.target.value); speedVal.textContent = speed; if (isRunning) schedule(); });
    document.getElementById('randomize').addEventListener('click', () => {
      snakeColor = randomHex(); foodColor = randomHex();
      snakeColorInput.value = snakeColor; foodColorInput.value = foodColor;
      refreshPatterns();
    });

    // Redraw on resize to keep DPR scaling accurate if device zoom changes
    window.addEventListener('resize', resizeCanvas);

    // Initial draw
    draw();
  </script>
</body>
</html>
